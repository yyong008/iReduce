## JS 堆栈

JavaScript 中的执行上下文（execution context）是按照一种称为“堆栈”（stack）的数据结构来管理的。执行上下文可以理解为函数执行时创建的环境，包含了变量、函数、作用域链等信息。

### JavaScript 中的堆栈：

1. **调用栈（Call Stack）**：

   - 调用栈是用来存储执行上下文的一种数据结构，遵循后进先出（LIFO）的原则。
   - 每当执行一个函数时，会创建该函数的执行上下文，并被推入调用栈的顶部（压栈）。
   - 当函数执行完成，其执行上下文会被从栈顶移除（出栈）。

2. **执行上下文（Execution Context）**：
   - 执行上下文是 JavaScript 中管理执行的抽象概念，包括变量、作用域链、this 指向等信息。
   - 在全局执行上下文外，每个函数调用都会创建一个新的执行上下文。

### 示例：

```javascript
function func1() {
  console.log("func1 开始执行");
  func2();
  console.log("func1 执行结束");
}

function func2() {
  console.log("func2 开始执行");
  func3();
  console.log("func2 执行结束");
}

function func3() {
  console.log("func3 开始执行");
  console.log("func3 执行结束");
}

func1();
```

#### 执行流程：

1. `func1()` 被调用，创建 `func1` 的执行上下文并被推入调用栈。
2. 在 `func1` 中调用 `func2()`，创建 `func2` 的执行上下文并被推入调用栈。
3. 在 `func2` 中调用 `func3()`，创建 `func3` 的执行上下文并被推入调用栈。
4. `func3` 执行完成，其执行上下文从调用栈中移除。
5. `func2` 执行完成，其执行上下文从调用栈中移除。
6. `func1` 执行完成，其执行上下文从调用栈中移除。

这个过程演示了调用栈的工作原理，以及函数执行时创建和销毁执行上下文的过程。理解调用栈有助于理解 JavaScript 中函数执行的顺序和上下文管理。

## 存放位置

在 JavaScript 中，基本类型的值（如数字、布尔值、字符串、undefined 和 null）通常被直接存储在栈内存中，而非堆内存中。这些基本类型的值被称为"原始值"，它们的存储和访问比较简单高效。

### 基本类型值在栈中的特点：

1. **存储位置**：

   - 基本类型的值直接存储在栈内存中，它们的大小是固定的，因此被简单地存储在变量所分配的内存空间中。

2. **访问速度**：

   - 因为存储在栈中，基本类型的值的访问速度较快，这是因为栈内存的读取速度通常比堆内存更快。

3. **按值访问**：
   - 基本类型的值是按值访问的，它们直接包含实际的数据。因此，当把一个基本类型的值赋给另一个变量时，会将原始值复制一份，两个变量互不影响。

例如：

```javascript
let a = 10; // 将数字 10 存储在变量 a 中
let b = a; // 将变量 a 的值复制给变量 b，实际上是复制了 10 的副本

a = 20; // 修改变量 a 的值为 20，不影响变量 b
console.log(b); // 输出为 10，因为 b 仍然持有 10 的值
```

基本类型的值在栈中的存储和访问速度快，但也存在一些限制，比如它们的大小是固定的，无法像引用类型那样存储复杂的数据结构。

## 栈放在堆里面的情况

在 JavaScript 中，基本类型的值通常是直接存储在栈内存中的，但有一种特殊情况，即当基本类型的值被赋予属性时，它们会被封装成对应的包装对象，这些对象会存储在堆内存中。

在 JavaScript 中，基本类型的值通常是直接存储在栈内存中的，但有一种特殊情况，即当基本类型的值被赋予属性时，它们会被封装成对应的包装对象，这些对象会存储在堆内存中。

### 基本类型值的封装对象：

1. **原始类型和其对应的封装对象**：

   - 原始类型：Number、Boolean、String、Symbol 等
   - 封装对象：Number 对象、Boolean 对象、String 对象、Symbol 对象

2. **赋值操作**：
   - 当基本类型的值被赋予属性或调用方法时，JavaScript 会临时将其转换为对应的封装对象，并在堆内存中存储这个临时对象。

```javascript
let num = 10; // 原始类型值存储在栈中
let numObj = new Number(10); // 封装对象存储在堆中

let str = "Hello"; // 原始类型值存储在栈中
let strObj = new String("Hello"); // 封装对象存储在堆中

console.log(typeof numObj); // 输出为 'object'
console.log(typeof strObj); // 输出为 'object'
```

这种封装对象的产生是 JavaScript 引擎的行为，为了在原始类型值上调用方法或赋予属性时能够正常操作，临时生成的封装对象会被自动释放，不会长期存在于堆内存中。
